"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resize-detector";
exports.ids = ["vendor-chunks/react-resize-detector"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resize-detector/build/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-resize-detector/build/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, \"__esModule\", ({value:true}));var React=__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"),reactDom=__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"),debounce=__webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\"),throttle=__webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}var patchResizeCallback = function (resizeCallback, refreshMode, refreshRate, refreshOptions) {\n    switch (refreshMode) {\n        case 'debounce':\n            return debounce(resizeCallback, refreshRate, refreshOptions);\n        case 'throttle':\n            return throttle(resizeCallback, refreshRate, refreshOptions);\n        default:\n            return resizeCallback;\n    }\n};\nvar isFunction = function (fn) { return typeof fn === 'function'; };\nvar isSSR = function () { return typeof window === 'undefined'; };\nvar isDOMElement = function (element) {\n    return element instanceof Element || element instanceof HTMLDocument;\n};var ResizeDetector = /** @class */ (function (_super) {\n    __extends(ResizeDetector, _super);\n    function ResizeDetector(props) {\n        var _this = _super.call(this, props) || this;\n        _this.cancelHandler = function () {\n            if (_this.resizeHandler && _this.resizeHandler.cancel) {\n                // cancel debounced handler\n                _this.resizeHandler.cancel();\n                _this.resizeHandler = null;\n            }\n        };\n        _this.attachObserver = function () {\n            var _a = _this.props, targetRef = _a.targetRef, observerOptions = _a.observerOptions;\n            if (isSSR()) {\n                return;\n            }\n            if (targetRef && targetRef.current) {\n                _this.targetRef.current = targetRef.current;\n            }\n            var element = _this.getElement();\n            if (!element) {\n                // can't find element to observe\n                return;\n            }\n            if (_this.observableElement && _this.observableElement === element) {\n                // element is already observed\n                return;\n            }\n            _this.observableElement = element;\n            _this.resizeObserver.observe(element, observerOptions);\n        };\n        _this.getElement = function () {\n            var _a = _this.props, querySelector = _a.querySelector, targetDomEl = _a.targetDomEl;\n            if (isSSR())\n                return null;\n            // in case we pass a querySelector\n            if (querySelector)\n                return document.querySelector(querySelector);\n            // in case we pass a DOM element\n            if (targetDomEl && isDOMElement(targetDomEl))\n                return targetDomEl;\n            // in case we pass a React ref using React.createRef()\n            if (_this.targetRef && isDOMElement(_this.targetRef.current))\n                return _this.targetRef.current;\n            // the worse case when we don't receive any information from the parent and the library doesn't add any wrappers\n            // we have to use a deprecated `findDOMNode` method in order to find a DOM element to attach to\n            var currentElement = reactDom.findDOMNode(_this);\n            if (!currentElement)\n                return null;\n            var renderType = _this.getRenderType();\n            switch (renderType) {\n                case 'renderProp':\n                    return currentElement;\n                case 'childFunction':\n                    return currentElement;\n                case 'child':\n                    return currentElement;\n                case 'childArray':\n                    return currentElement;\n                default:\n                    return currentElement.parentElement;\n            }\n        };\n        _this.createResizeHandler = function (entries) {\n            var _a = _this.props, _b = _a.handleWidth, handleWidth = _b === void 0 ? true : _b, _c = _a.handleHeight, handleHeight = _c === void 0 ? true : _c, onResize = _a.onResize;\n            if (!handleWidth && !handleHeight)\n                return;\n            var notifyResize = function (_a) {\n                var width = _a.width, height = _a.height;\n                if (_this.state.width === width && _this.state.height === height) {\n                    // skip if dimensions haven't changed\n                    return;\n                }\n                if ((_this.state.width === width && !handleHeight) || (_this.state.height === height && !handleWidth)) {\n                    // process `handleHeight/handleWidth` props\n                    return;\n                }\n                onResize === null || onResize === void 0 ? void 0 : onResize(width, height);\n                _this.setState({ width: width, height: height });\n            };\n            entries.forEach(function (entry) {\n                var _a = (entry && entry.contentRect) || {}, width = _a.width, height = _a.height;\n                var shouldSetSize = !_this.skipOnMount && !isSSR();\n                if (shouldSetSize) {\n                    notifyResize({ width: width, height: height });\n                }\n                _this.skipOnMount = false;\n            });\n        };\n        _this.getRenderType = function () {\n            var _a = _this.props, render = _a.render, children = _a.children;\n            if (isFunction(render)) {\n                // DEPRECATED. Use `Child Function Pattern` instead\n                return 'renderProp';\n            }\n            if (isFunction(children)) {\n                return 'childFunction';\n            }\n            if (React.isValidElement(children)) {\n                return 'child';\n            }\n            if (Array.isArray(children)) {\n                // DEPRECATED. Wrap children with a single parent\n                return 'childArray';\n            }\n            // DEPRECATED. Use `Child Function Pattern` instead\n            return 'parent';\n        };\n        var skipOnMount = props.skipOnMount, refreshMode = props.refreshMode, _a = props.refreshRate, refreshRate = _a === void 0 ? 1000 : _a, refreshOptions = props.refreshOptions;\n        _this.state = {\n            width: undefined,\n            height: undefined\n        };\n        _this.sizeRef = {\n            current: _this.state\n        };\n        _this.skipOnMount = skipOnMount;\n        _this.targetRef = React.createRef();\n        _this.observableElement = null;\n        if (isSSR()) {\n            return _this;\n        }\n        _this.resizeHandler = patchResizeCallback(_this.createResizeHandler, refreshMode, refreshRate, refreshOptions);\n        _this.resizeObserver = new window.ResizeObserver(_this.resizeHandler);\n        return _this;\n    }\n    ResizeDetector.prototype.componentDidMount = function () {\n        this.attachObserver();\n    };\n    ResizeDetector.prototype.componentDidUpdate = function () {\n        this.attachObserver();\n        this.sizeRef.current = this.state;\n    };\n    ResizeDetector.prototype.componentWillUnmount = function () {\n        if (isSSR()) {\n            return;\n        }\n        this.observableElement = null;\n        this.resizeObserver.disconnect();\n        this.cancelHandler();\n    };\n    ResizeDetector.prototype.render = function () {\n        var _a = this.props, render = _a.render, children = _a.children, _b = _a.nodeType, WrapperTag = _b === void 0 ? 'div' : _b;\n        var _c = this.state, width = _c.width, height = _c.height;\n        var childProps = { width: width, height: height, targetRef: this.targetRef };\n        var renderType = this.getRenderType();\n        switch (renderType) {\n            case 'renderProp':\n                return render === null || render === void 0 ? void 0 : render(childProps);\n            case 'childFunction': {\n                var childFunction = children;\n                return childFunction === null || childFunction === void 0 ? void 0 : childFunction(childProps);\n            }\n            case 'child': {\n                // @TODO bug prone logic\n                var child = children;\n                if (child.type && typeof child.type === 'string') {\n                    // child is a native DOM elements such as div, span etc\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    childProps.targetRef; var nativeProps = __rest(childProps, [\"targetRef\"]);\n                    return React.cloneElement(child, nativeProps);\n                }\n                // class or functional component otherwise\n                return React.cloneElement(child, childProps);\n            }\n            case 'childArray': {\n                var childArray = children;\n                return childArray.map(function (el) { return !!el && React.cloneElement(el, childProps); });\n            }\n            default:\n                return React.createElement(WrapperTag, null);\n        }\n    };\n    return ResizeDetector;\n}(React.PureComponent));function withResizeDetector(ComponentInner, options) {\n    if (options === void 0) { options = {}; }\n    var ResizeDetectorHOC = /** @class */ (function (_super) {\n        __extends(ResizeDetectorHOC, _super);\n        function ResizeDetectorHOC() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.ref = React.createRef();\n            return _this;\n        }\n        ResizeDetectorHOC.prototype.render = function () {\n            var _a = this.props, forwardedRef = _a.forwardedRef, rest = __rest(_a, [\"forwardedRef\"]);\n            var targetRef = forwardedRef !== null && forwardedRef !== void 0 ? forwardedRef : this.ref;\n            return (React.createElement(ResizeDetector, __assign({}, options, { targetRef: targetRef }),\n                React.createElement(ComponentInner, __assign({ targetRef: targetRef }, rest))));\n        };\n        return ResizeDetectorHOC;\n    }(React.Component));\n    function forwardRefWrapper(props, ref) {\n        return React.createElement(ResizeDetectorHOC, __assign({}, props, { forwardedRef: ref }));\n    }\n    var name = ComponentInner.displayName || ComponentInner.name;\n    forwardRefWrapper.displayName = \"withResizeDetector(\".concat(name, \")\");\n    return React.forwardRef(forwardRefWrapper);\n}function useResizeDetector(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.skipOnMount, skipOnMount = _c === void 0 ? false : _c, refreshMode = _b.refreshMode, _d = _b.refreshRate, refreshRate = _d === void 0 ? 1000 : _d, refreshOptions = _b.refreshOptions, _e = _b.handleWidth, handleWidth = _e === void 0 ? true : _e, _f = _b.handleHeight, handleHeight = _f === void 0 ? true : _f, targetRef = _b.targetRef, observerOptions = _b.observerOptions, onResize = _b.onResize;\n    var skipResize = React.useRef(skipOnMount);\n    var _g = React.useState({\n        width: undefined,\n        height: undefined\n    }), size = _g[0], setSize = _g[1];\n    // we are going to use this ref to store the last element that was passed to the hook\n    var _h = React.useState((targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) || null), refElement = _h[0], setRefElement = _h[1];\n    // if targetRef is passed, we need to update the refElement\n    // we have to use setTimeout because ref get assigned after the hook is called\n    // in the future releases we are going to remove targetRef and force users to use ref returned by the hook\n    if (targetRef) {\n        setTimeout(function () {\n            if (targetRef.current !== refElement) {\n                setRefElement(targetRef.current);\n            }\n        }, 0);\n    }\n    // this is a callback that will be called every time the ref is changed\n    // we call setState inside to trigger rerender\n    var onRefChange = React.useCallback(function (node) {\n        if (node !== refElement) {\n            setRefElement(node);\n        }\n    }, [refElement]);\n    // adding `current` to make it compatible with useRef shape\n    onRefChange.current = refElement;\n    React.useEffect(function () {\n        return function () {\n            // component is unmounted\n            // clear ref to avoid memory leaks\n            setRefElement(null);\n            onRefChange.current = null;\n        };\n    }, []);\n    var shouldSetSize = React.useCallback(function (prevSize, nextSize) {\n        if (prevSize.width === nextSize.width && prevSize.height === nextSize.height) {\n            // skip if dimensions haven't changed\n            return false;\n        }\n        if ((prevSize.width === nextSize.width && !handleHeight) ||\n            (prevSize.height === nextSize.height && !handleWidth)) {\n            // process `handleHeight/handleWidth` props\n            return false;\n        }\n        return true;\n    }, [handleWidth, handleHeight]);\n    var resizeCallback = React.useCallback(function (entries) {\n        if (!handleWidth && !handleHeight)\n            return;\n        if (skipResize.current) {\n            skipResize.current = false;\n            return;\n        }\n        entries.forEach(function (entry) {\n            var _a = (entry === null || entry === void 0 ? void 0 : entry.contentRect) || {}, width = _a.width, height = _a.height;\n            setSize(function (prevSize) {\n                if (!shouldSetSize(prevSize, { width: width, height: height }))\n                    return prevSize;\n                return { width: width, height: height };\n            });\n        });\n    }, [handleWidth, handleHeight, skipResize, shouldSetSize]);\n    var resizeHandler = React.useCallback(patchResizeCallback(resizeCallback, refreshMode, refreshRate, refreshOptions), [\n        resizeCallback,\n        refreshMode,\n        refreshRate,\n        refreshOptions\n    ]);\n    // on refElement change\n    React.useEffect(function () {\n        var resizeObserver;\n        if (refElement) {\n            resizeObserver = new window.ResizeObserver(resizeHandler);\n            resizeObserver.observe(refElement, observerOptions);\n        }\n        else {\n            if (size.width || size.height) {\n                setSize({ width: undefined, height: undefined });\n            }\n        }\n        return function () {\n            var _a, _b, _c;\n            (_a = resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect) === null || _a === void 0 ? void 0 : _a.call(resizeObserver);\n            (_c = (_b = resizeHandler).cancel) === null || _c === void 0 ? void 0 : _c.call(_b);\n        };\n    }, [resizeHandler, refElement]);\n    React.useEffect(function () {\n        onResize === null || onResize === void 0 ? void 0 : onResize(size.width, size.height);\n    }, [size]);\n    return __assign({ ref: onRefChange }, size);\n}exports[\"default\"]=ResizeDetector;exports.useResizeDetector=useResizeDetector;exports.withResizeDetector=withResizeDetector;//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXplLWRldGVjdG9yL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLFVBQVUsbUJBQU8sQ0FBQyx3R0FBTyxXQUFXLG1CQUFPLENBQUMsZ0hBQVcsV0FBVyxtQkFBTyxDQUFDLGdFQUFpQixXQUFXLG1CQUFPLENBQUMsZ0VBQWlCLEVBQUU7QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9EO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0RBQW9EO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCO0FBQ3hCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhLHNCQUFzQjtBQUN0RywrREFBK0Qsc0JBQXNCO0FBQ3JGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUUsV0FBVyxtQkFBbUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0Isa0JBQWtCO0FBQ3hDLENBQUMsa0JBQWUsZ0JBQWdCLHlCQUF5QixtQkFBbUIsMEJBQTBCLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BhZ2VwYXVsLmFpLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6ZS1kZXRlY3Rvci9idWlsZC9pbmRleC5qcz9jYjY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnX19lc01vZHVsZScse3ZhbHVlOnRydWV9KTt2YXIgUmVhY3Q9cmVxdWlyZSgncmVhY3QnKSxyZWFjdERvbT1yZXF1aXJlKCdyZWFjdC1kb20nKSxkZWJvdW5jZT1yZXF1aXJlKCdsb2Rhc2gvZGVib3VuY2UnKSx0aHJvdHRsZT1yZXF1aXJlKCdsb2Rhc2gvdGhyb3R0bGUnKTsvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59dmFyIHBhdGNoUmVzaXplQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzaXplQ2FsbGJhY2ssIHJlZnJlc2hNb2RlLCByZWZyZXNoUmF0ZSwgcmVmcmVzaE9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKHJlZnJlc2hNb2RlKSB7XG4gICAgICAgIGNhc2UgJ2RlYm91bmNlJzpcbiAgICAgICAgICAgIHJldHVybiBkZWJvdW5jZShyZXNpemVDYWxsYmFjaywgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKTtcbiAgICAgICAgY2FzZSAndGhyb3R0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIHRocm90dGxlKHJlc2l6ZUNhbGxiYWNrLCByZWZyZXNoUmF0ZSwgcmVmcmVzaE9wdGlvbnMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZUNhbGxiYWNrO1xuICAgIH1cbn07XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nOyB9O1xudmFyIGlzU1NSID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7IH07XG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudDtcbn07dmFyIFJlc2l6ZURldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNpemVEZXRlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNpemVEZXRlY3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2FuY2VsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXNpemVIYW5kbGVyICYmIF90aGlzLnJlc2l6ZUhhbmRsZXIuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGRlYm91bmNlZCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplSGFuZGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYXR0YWNoT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgdGFyZ2V0UmVmID0gX2EudGFyZ2V0UmVmLCBvYnNlcnZlck9wdGlvbnMgPSBfYS5vYnNlcnZlck9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoaXNTU1IoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRSZWYgJiYgdGFyZ2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXRSZWYuY3VycmVudCA9IHRhcmdldFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW4ndCBmaW5kIGVsZW1lbnQgdG8gb2JzZXJ2ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZhYmxlRWxlbWVudCAmJiBfdGhpcy5vYnNlcnZhYmxlRWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBvYnNlcnZlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGVFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBxdWVyeVNlbGVjdG9yID0gX2EucXVlcnlTZWxlY3RvciwgdGFyZ2V0RG9tRWwgPSBfYS50YXJnZXREb21FbDtcbiAgICAgICAgICAgIGlmIChpc1NTUigpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBwYXNzIGEgcXVlcnlTZWxlY3RvclxuICAgICAgICAgICAgaWYgKHF1ZXJ5U2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnlTZWxlY3Rvcik7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIHBhc3MgYSBET00gZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRhcmdldERvbUVsICYmIGlzRE9NRWxlbWVudCh0YXJnZXREb21FbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldERvbUVsO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBwYXNzIGEgUmVhY3QgcmVmIHVzaW5nIFJlYWN0LmNyZWF0ZVJlZigpXG4gICAgICAgICAgICBpZiAoX3RoaXMudGFyZ2V0UmVmICYmIGlzRE9NRWxlbWVudChfdGhpcy50YXJnZXRSZWYuY3VycmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRhcmdldFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgLy8gdGhlIHdvcnNlIGNhc2Ugd2hlbiB3ZSBkb24ndCByZWNlaXZlIGFueSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwYXJlbnQgYW5kIHRoZSBsaWJyYXJ5IGRvZXNuJ3QgYWRkIGFueSB3cmFwcGVyc1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byB1c2UgYSBkZXByZWNhdGVkIGBmaW5kRE9NTm9kZWAgbWV0aG9kIGluIG9yZGVyIHRvIGZpbmQgYSBET00gZWxlbWVudCB0byBhdHRhY2ggdG9cbiAgICAgICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IHJlYWN0RG9tLmZpbmRET01Ob2RlKF90aGlzKTtcbiAgICAgICAgICAgIGlmICghY3VycmVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVHlwZSA9IF90aGlzLmdldFJlbmRlclR5cGUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVuZGVyVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlbmRlclByb3AnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hpbGRGdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGlsZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGlsZEFycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jcmVhdGVSZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBfYiA9IF9hLmhhbmRsZVdpZHRoLCBoYW5kbGVXaWR0aCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gX2EuaGFuZGxlSGVpZ2h0LCBoYW5kbGVIZWlnaHQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBvblJlc2l6ZSA9IF9hLm9uUmVzaXplO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVXaWR0aCAmJiAhaGFuZGxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBub3RpZnlSZXNpemUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS53aWR0aCA9PT0gd2lkdGggJiYgX3RoaXMuc3RhdGUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBkaW1lbnNpb25zIGhhdmVuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoX3RoaXMuc3RhdGUud2lkdGggPT09IHdpZHRoICYmICFoYW5kbGVIZWlnaHQpIHx8IChfdGhpcy5zdGF0ZS5oZWlnaHQgPT09IGhlaWdodCAmJiAhaGFuZGxlV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgYGhhbmRsZUhlaWdodC9oYW5kbGVXaWR0aGAgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblJlc2l6ZSA9PT0gbnVsbCB8fCBvblJlc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25SZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSAoZW50cnkgJiYgZW50cnkuY29udGVudFJlY3QpIHx8IHt9LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFNldFNpemUgPSAhX3RoaXMuc2tpcE9uTW91bnQgJiYgIWlzU1NSKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNldFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5UmVzaXplKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc2tpcE9uTW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRSZW5kZXJUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHJlbmRlciA9IF9hLnJlbmRlciwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHJlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBERVBSRUNBVEVELiBVc2UgYENoaWxkIEZ1bmN0aW9uIFBhdHRlcm5gIGluc3RlYWRcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JlbmRlclByb3AnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjaGlsZEZ1bmN0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoaWxkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIC8vIERFUFJFQ0FURUQuIFdyYXAgY2hpbGRyZW4gd2l0aCBhIHNpbmdsZSBwYXJlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoaWxkQXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRC4gVXNlIGBDaGlsZCBGdW5jdGlvbiBQYXR0ZXJuYCBpbnN0ZWFkXG4gICAgICAgICAgICByZXR1cm4gJ3BhcmVudCc7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBza2lwT25Nb3VudCA9IHByb3BzLnNraXBPbk1vdW50LCByZWZyZXNoTW9kZSA9IHByb3BzLnJlZnJlc2hNb2RlLCBfYSA9IHByb3BzLnJlZnJlc2hSYXRlLCByZWZyZXNoUmF0ZSA9IF9hID09PSB2b2lkIDAgPyAxMDAwIDogX2EsIHJlZnJlc2hPcHRpb25zID0gcHJvcHMucmVmcmVzaE9wdGlvbnM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhlaWdodDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNpemVSZWYgPSB7XG4gICAgICAgICAgICBjdXJyZW50OiBfdGhpcy5zdGF0ZVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5za2lwT25Nb3VudCA9IHNraXBPbk1vdW50O1xuICAgICAgICBfdGhpcy50YXJnZXRSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMub2JzZXJ2YWJsZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNTU1IoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnJlc2l6ZUhhbmRsZXIgPSBwYXRjaFJlc2l6ZUNhbGxiYWNrKF90aGlzLmNyZWF0ZVJlc2l6ZUhhbmRsZXIsIHJlZnJlc2hNb2RlLCByZWZyZXNoUmF0ZSwgcmVmcmVzaE9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoX3RoaXMucmVzaXplSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzaXplRGV0ZWN0b3IucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmF0dGFjaE9ic2VydmVyKCk7XG4gICAgfTtcbiAgICBSZXNpemVEZXRlY3Rvci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmF0dGFjaE9ic2VydmVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZVJlZi5jdXJyZW50ID0gdGhpcy5zdGF0ZTtcbiAgICB9O1xuICAgIFJlc2l6ZURldGVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzU1NSKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmFibGVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuY2FuY2VsSGFuZGxlcigpO1xuICAgIH07XG4gICAgUmVzaXplRGV0ZWN0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgcmVuZGVyID0gX2EucmVuZGVyLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYiA9IF9hLm5vZGVUeXBlLCBXcmFwcGVyVGFnID0gX2IgPT09IHZvaWQgMCA/ICdkaXYnIDogX2I7XG4gICAgICAgIHZhciBfYyA9IHRoaXMuc3RhdGUsIHdpZHRoID0gX2Mud2lkdGgsIGhlaWdodCA9IF9jLmhlaWdodDtcbiAgICAgICAgdmFyIGNoaWxkUHJvcHMgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHRhcmdldFJlZjogdGhpcy50YXJnZXRSZWYgfTtcbiAgICAgICAgdmFyIHJlbmRlclR5cGUgPSB0aGlzLmdldFJlbmRlclR5cGUoKTtcbiAgICAgICAgc3dpdGNoIChyZW5kZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdyZW5kZXJQcm9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyID09PSBudWxsIHx8IHJlbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyKGNoaWxkUHJvcHMpO1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRGdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRGdW5jdGlvbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEZ1bmN0aW9uID09PSBudWxsIHx8IGNoaWxkRnVuY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkRnVuY3Rpb24oY2hpbGRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjaGlsZCc6IHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETyBidWcgcHJvbmUgbG9naWNcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAmJiB0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGQgaXMgYSBuYXRpdmUgRE9NIGVsZW1lbnRzIHN1Y2ggYXMgZGl2LCBzcGFuIGV0Y1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcHMudGFyZ2V0UmVmOyB2YXIgbmF0aXZlUHJvcHMgPSBfX3Jlc3QoY2hpbGRQcm9wcywgW1widGFyZ2V0UmVmXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgbmF0aXZlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGFzcyBvciBmdW5jdGlvbmFsIGNvbXBvbmVudCBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQXJyYXkgPSBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRBcnJheS5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsICYmIFJlYWN0LmNsb25lRWxlbWVudChlbCwgY2hpbGRQcm9wcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyVGFnLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZURldGVjdG9yO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KSk7ZnVuY3Rpb24gd2l0aFJlc2l6ZURldGVjdG9yKENvbXBvbmVudElubmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgUmVzaXplRGV0ZWN0b3JIT0MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhSZXNpemVEZXRlY3RvckhPQywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplRGV0ZWN0b3JIT0MoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZURldGVjdG9ySE9DLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBmb3J3YXJkZWRSZWYgPSBfYS5mb3J3YXJkZWRSZWYsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZvcndhcmRlZFJlZlwiXSk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UmVmID0gZm9yd2FyZGVkUmVmICE9PSBudWxsICYmIGZvcndhcmRlZFJlZiAhPT0gdm9pZCAwID8gZm9yd2FyZGVkUmVmIDogdGhpcy5yZWY7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzaXplRGV0ZWN0b3IsIF9fYXNzaWduKHt9LCBvcHRpb25zLCB7IHRhcmdldFJlZjogdGFyZ2V0UmVmIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50SW5uZXIsIF9fYXNzaWduKHsgdGFyZ2V0UmVmOiB0YXJnZXRSZWYgfSwgcmVzdCkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXNpemVEZXRlY3RvckhPQztcbiAgICB9KFJlYWN0LkNvbXBvbmVudCkpO1xuICAgIGZ1bmN0aW9uIGZvcndhcmRSZWZXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzaXplRGV0ZWN0b3JIT0MsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRSZWY6IHJlZiB9KSk7XG4gICAgfVxuICAgIHZhciBuYW1lID0gQ29tcG9uZW50SW5uZXIuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50SW5uZXIubmFtZTtcbiAgICBmb3J3YXJkUmVmV3JhcHBlci5kaXNwbGF5TmFtZSA9IFwid2l0aFJlc2l6ZURldGVjdG9yKFwiLmNvbmNhdChuYW1lLCBcIilcIik7XG4gICAgcmV0dXJuIFJlYWN0LmZvcndhcmRSZWYoZm9yd2FyZFJlZldyYXBwZXIpO1xufWZ1bmN0aW9uIHVzZVJlc2l6ZURldGVjdG9yKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2Iuc2tpcE9uTW91bnQsIHNraXBPbk1vdW50ID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIHJlZnJlc2hNb2RlID0gX2IucmVmcmVzaE1vZGUsIF9kID0gX2IucmVmcmVzaFJhdGUsIHJlZnJlc2hSYXRlID0gX2QgPT09IHZvaWQgMCA/IDEwMDAgOiBfZCwgcmVmcmVzaE9wdGlvbnMgPSBfYi5yZWZyZXNoT3B0aW9ucywgX2UgPSBfYi5oYW5kbGVXaWR0aCwgaGFuZGxlV2lkdGggPSBfZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9lLCBfZiA9IF9iLmhhbmRsZUhlaWdodCwgaGFuZGxlSGVpZ2h0ID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZiwgdGFyZ2V0UmVmID0gX2IudGFyZ2V0UmVmLCBvYnNlcnZlck9wdGlvbnMgPSBfYi5vYnNlcnZlck9wdGlvbnMsIG9uUmVzaXplID0gX2Iub25SZXNpemU7XG4gICAgdmFyIHNraXBSZXNpemUgPSBSZWFjdC51c2VSZWYoc2tpcE9uTW91bnQpO1xuICAgIHZhciBfZyA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVpZ2h0OiB1bmRlZmluZWRcbiAgICB9KSwgc2l6ZSA9IF9nWzBdLCBzZXRTaXplID0gX2dbMV07XG4gICAgLy8gd2UgYXJlIGdvaW5nIHRvIHVzZSB0aGlzIHJlZiB0byBzdG9yZSB0aGUgbGFzdCBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgaG9va1xuICAgIHZhciBfaCA9IFJlYWN0LnVzZVN0YXRlKCh0YXJnZXRSZWYgPT09IG51bGwgfHwgdGFyZ2V0UmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRSZWYuY3VycmVudCkgfHwgbnVsbCksIHJlZkVsZW1lbnQgPSBfaFswXSwgc2V0UmVmRWxlbWVudCA9IF9oWzFdO1xuICAgIC8vIGlmIHRhcmdldFJlZiBpcyBwYXNzZWQsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByZWZFbGVtZW50XG4gICAgLy8gd2UgaGF2ZSB0byB1c2Ugc2V0VGltZW91dCBiZWNhdXNlIHJlZiBnZXQgYXNzaWduZWQgYWZ0ZXIgdGhlIGhvb2sgaXMgY2FsbGVkXG4gICAgLy8gaW4gdGhlIGZ1dHVyZSByZWxlYXNlcyB3ZSBhcmUgZ29pbmcgdG8gcmVtb3ZlIHRhcmdldFJlZiBhbmQgZm9yY2UgdXNlcnMgdG8gdXNlIHJlZiByZXR1cm5lZCBieSB0aGUgaG9va1xuICAgIGlmICh0YXJnZXRSZWYpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVmLmN1cnJlbnQgIT09IHJlZkVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWZFbGVtZW50KHRhcmdldFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHJlZiBpcyBjaGFuZ2VkXG4gICAgLy8gd2UgY2FsbCBzZXRTdGF0ZSBpbnNpZGUgdG8gdHJpZ2dlciByZXJlbmRlclxuICAgIHZhciBvblJlZkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlICE9PSByZWZFbGVtZW50KSB7XG4gICAgICAgICAgICBzZXRSZWZFbGVtZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgfSwgW3JlZkVsZW1lbnRdKTtcbiAgICAvLyBhZGRpbmcgYGN1cnJlbnRgIHRvIG1ha2UgaXQgY29tcGF0aWJsZSB3aXRoIHVzZVJlZiBzaGFwZVxuICAgIG9uUmVmQ2hhbmdlLmN1cnJlbnQgPSByZWZFbGVtZW50O1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb21wb25lbnQgaXMgdW5tb3VudGVkXG4gICAgICAgICAgICAvLyBjbGVhciByZWYgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICBzZXRSZWZFbGVtZW50KG51bGwpO1xuICAgICAgICAgICAgb25SZWZDaGFuZ2UuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciBzaG91bGRTZXRTaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHByZXZTaXplLCBuZXh0U2l6ZSkge1xuICAgICAgICBpZiAocHJldlNpemUud2lkdGggPT09IG5leHRTaXplLndpZHRoICYmIHByZXZTaXplLmhlaWdodCA9PT0gbmV4dFNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBza2lwIGlmIGRpbWVuc2lvbnMgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcmV2U2l6ZS53aWR0aCA9PT0gbmV4dFNpemUud2lkdGggJiYgIWhhbmRsZUhlaWdodCkgfHxcbiAgICAgICAgICAgIChwcmV2U2l6ZS5oZWlnaHQgPT09IG5leHRTaXplLmhlaWdodCAmJiAhaGFuZGxlV2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzIGBoYW5kbGVIZWlnaHQvaGFuZGxlV2lkdGhgIHByb3BzXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgW2hhbmRsZVdpZHRoLCBoYW5kbGVIZWlnaHRdKTtcbiAgICB2YXIgcmVzaXplQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICBpZiAoIWhhbmRsZVdpZHRoICYmICFoYW5kbGVIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChza2lwUmVzaXplLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNraXBSZXNpemUuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkuY29udGVudFJlY3QpIHx8IHt9LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgICAgICBzZXRTaXplKGZ1bmN0aW9uIChwcmV2U2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkU2V0U2l6ZShwcmV2U2l6ZSwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlNpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtoYW5kbGVXaWR0aCwgaGFuZGxlSGVpZ2h0LCBza2lwUmVzaXplLCBzaG91bGRTZXRTaXplXSk7XG4gICAgdmFyIHJlc2l6ZUhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjayhwYXRjaFJlc2l6ZUNhbGxiYWNrKHJlc2l6ZUNhbGxiYWNrLCByZWZyZXNoTW9kZSwgcmVmcmVzaFJhdGUsIHJlZnJlc2hPcHRpb25zKSwgW1xuICAgICAgICByZXNpemVDYWxsYmFjayxcbiAgICAgICAgcmVmcmVzaE1vZGUsXG4gICAgICAgIHJlZnJlc2hSYXRlLFxuICAgICAgICByZWZyZXNoT3B0aW9uc1xuICAgIF0pO1xuICAgIC8vIG9uIHJlZkVsZW1lbnQgY2hhbmdlXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc2l6ZU9ic2VydmVyO1xuICAgICAgICBpZiAocmVmRWxlbWVudCkge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKHJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWZFbGVtZW50LCBvYnNlcnZlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzZXRTaXplKHsgd2lkdGg6IHVuZGVmaW5lZCwgaGVpZ2h0OiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgKF9hID0gcmVzaXplT2JzZXJ2ZXIgPT09IG51bGwgfHwgcmVzaXplT2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgICAgIChfYyA9IChfYiA9IHJlc2l6ZUhhbmRsZXIpLmNhbmNlbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZXNpemVIYW5kbGVyLCByZWZFbGVtZW50XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25SZXNpemUgPT09IG51bGwgfHwgb25SZXNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUmVzaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICB9LCBbc2l6ZV0pO1xuICAgIHJldHVybiBfX2Fzc2lnbih7IHJlZjogb25SZWZDaGFuZ2UgfSwgc2l6ZSk7XG59ZXhwb3J0cy5kZWZhdWx0PVJlc2l6ZURldGVjdG9yO2V4cG9ydHMudXNlUmVzaXplRGV0ZWN0b3I9dXNlUmVzaXplRGV0ZWN0b3I7ZXhwb3J0cy53aXRoUmVzaXplRGV0ZWN0b3I9d2l0aFJlc2l6ZURldGVjdG9yOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resize-detector/build/index.js\n");

/***/ })

};
;